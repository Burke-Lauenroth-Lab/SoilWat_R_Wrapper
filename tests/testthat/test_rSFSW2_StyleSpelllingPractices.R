context("Code style, spell checks, and good package practices")


#--- Code style
test_that("Package code style", {
  # Check locally and on travis
  skip_on_cran()
  skip_on_appveyor()
  # minimum version of lintr required for:
  #  - empty commas in multi-dimensional array subsetting, e.g., x[, , 1:3]
  skip_if_not_installed("lintr", minimum_version = "1.0.2.9000")


  # Files that are not checked for lints
  files_not_tolint <- c(
    "ExtractData_ClimateDownscaling.R", # needs linting
    "Simulation_Run.R", # needs linting
    "OutputDatabase_Ensembles.R", # this is de-facto deprecated & defunct
    "RcppExports.R" # this is generated by Rcpp
  )

  # Note: working directory when these tests are run is at `tests/testthat/`
  if (TRUE) {
    # `expect_lint_free` as of v1.0.2.9000 (built 2018-05-27)
    #   - calls `testthat::skip_on_cran()`
    #   - argument `exclusions` is documented to take
    #     "[filenames] relative to the package path
    #     --> I find that only absolute paths works correctly
    lintr::expect_lint_free(
      # Files that should not be linted:
      exclusions = as.list(
        normalizePath(file.path("..", "..", "R", files_not_tolint))))

  } else {
    # for interactive use: easier to work with than `expect_lint_free`
    temp <- list(
      dir_R = file.path("..", "..", "R"),
      dir_testthat = file.path("."),
      dir_testdata = file.path("..", "test_data"))
    files <- unlist(lapply(temp, function(dir)
      list.files(dir, pattern = "(.R$)|(.r$)", full.names = TRUE)))
    files_tolint <- files[!(basename(files) %in% files_not_tolint)]

    for (k in seq_along(files_tolint)) {
      badstyle <- lintr::lint(files_tolint[k])
      expect_identical(length(badstyle), 0L, info = print(badstyle))
    }
  }
})



#--- Spell check documentation
test_that("Package spell checks", {
  # Check locally and on travis
  skip_on_cran()
  skip_on_appveyor()
  skip_if_not_installed("devtools")

  # ignore additional words (keep as short as possible)
  spell_ignores <- scan("../test_data/spell_words.txt", what = "character",
    comment.char = "#", quiet = TRUE)

  # against initial believe, we do not need to ignore R function names
  if (FALSE) {
    # ignore R functions of packages on the search path
    temp <- grep("package:", search(), value = TRUE)
    R_functions1 <- sort(unique(unlist(lapply(temp, function(pkg)
      as.character(lsf.str(pkg))))))

    # ignore R functions of packages imported, suggested, or linked to by rSFSW2
    temp <- utils::packageDescription("rSFSW2", fields = c("Depends",
      "Imports", "Suggests", "LinkingTo"))
    temp <- unname(unlist(sapply(temp,
      tools:::.extract_dependency_package_names)))
    R_functions2 <- sort(unique(unlist(lapply(temp, getNamespaceExports))))
  }

  # Spell check with `hunspell`:
  #   ignores text in roxygen2 content directives, e.g., \url{}, \var{},
  #   but checks text in roxygen2 formatting directives, e.g., \sQuote{}
  misspelled <- devtools::spell_check(ignore = spell_ignores)

  expect_identical(length(misspelled), 0L, info = print(misspelled))
})



#---
test_that("Package good practices", {
  skip(paste("rSFSW2 is not ready for 'good practices' ...;",
    "'goodpractice' should be run manually instead"))
  skip_on_cran()
  skip_on_travis()
  skip_on_appveyor()
  skip_if_not_installed("goodpractice")

  # this path assumes that the current working directory is
  # locatd at 'rSFSW2/tests/testthat/'
  gps <- goodpractice::gp(path = "../..")

  expect_identical(length(goodpractice::failed_checks(gps)), 0L,
    info = print(gps))
})
